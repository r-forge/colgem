#~ 2-type birth-death model; we will estimate within-deme and between-deme birth rates and population size
#~ simulated tree using MASTER 1.4.1 http://tgvaughan.github.io/MASTER/
#~ simulation used Gillespie discrete event methods;  
#~ post-process tree using phytools- see read_master.R
#~ see BDModel2type.xml for model specification
#~ We will fit a deterministic model to the simulated data, providing approximate MLEs of birth rates


#~ true parameter values
b00 <- 1; b11 <- 1; b01 <- .5; b10 <- .5; d0 <- 1; d1 <- 1
simulationTime <- 10 # simulated from 0..10
phi <- .25 # sample fraction


require(rcolgem)
require(deSolve)
require(ape)
require(rjson)
require(stats4)

#~ load the simulation data generated by MASTER
bdSimulationData <- fromJSON(file= system.file('extdata/BDModel2type.json', package = "rcolgem") )

#~ # load the tree into an ape::phylo
tree <- read.tree( system.file('extdata/BDModel2type.nwk', package = "rcolgem") )


#~ # downsample (the tree includes all cases)
#~ # 1st remove all leaves at end of sim
ntips <- length(tree$tip.label) 
d2root <- dist.nodes(tree)[ntips+1, 1:length(tree$tip.label) ]
names(d2root) <- tree$tip.label
maxDistanceFromRoot <- max( d2root )
sampleTimes <- c()
for (tip in tree$tip.label ) {
	if (d2root[tip] == maxDistanceFromRoot ) { #== maxDistanceFromRoot > dontSampleAfter
		tree <- drop.tip(tree, tip) 
	} else{
		if (runif(1) < 1-phi) { 
			tree <- drop.tip(tree, tip) 
		}
		else{ #sampled and record sampletime
			sampleTimes[tip] <- d2root[tip]
		}
	}
}
n <- length(tree$tip.label)


#~ the tip.labels are annotated with the state of the patient at time of sampling
calcStateFromName <-function(tl)
{
	lentl <- nchar(tl)
	tailstr <- substr(tl, lentl-1, lentl)
	if (tailstr == 'Y0' ){ return(c(1,0)) }
	return(c(0,1))
}
sampleStates <- t( sapply(tree$tip.label, calcStateFromName) )

#~ make a dated tree
bdt <- binaryDatedTree(tree, sampleTimes, sampleStates)

#~ write the Model in the canonical (F,G,Y) format
#~ derivative wrt state variable X=c(Y0, Y1)
FofY <- function(X, param)
{
  return(  matrix( rbind(
    c(X['Y0'] * param$b00, X['Y0'] * param$b01), 
    c(X['Y1'] * param$b10, X['Y1'] * param$b11)) 
    , 2,2)) 
}

dX <- function(t, X, param, ...)
{ 
.F <- FofY(X, param)
csF <- colSums(.F)
list(unname(c(
	csF[1] - d0*X['Y0'],
	csF[2] - d1*X['Y1']
 )))
}

#~ this function 1. solves the model 2. defines the Y.,F.,G. globals 3. calculates -log(likelihood)
#~ assume death rates are known
#~ NOTE: we estimate the transformed variables log(x) because the rate parameters are confined to (0, Inf)
integrate.model.calculate.minusLogLikelihood <- function(log_b_in, log_b_cross, logY0_0)
{
	param <- list(b00 = unname(exp(log_b_in)), b01 = unname(exp(log_b_cross)), b10= unname(exp((log_b_cross))), b11 = unname(exp(log_b_in) ) ) 
	X0 <-c( Y0=unname(exp(logY0_0)), Y1=unname(exp(logY0_0)) )
	times <- seq(0, max(sampleTimes), length.out = 100) 
	tryCatch( {o <- ode(X0, times, dX, param)}, error = function(e) { return(Inf) } )
	Y0 <- approxfun( o[,1], o[,2] )
	Y1 <- approxfun( o[,1], o[,3] )
	Y. <<- function(t) { c(Y0 = Y0(t), Y1 = Y1(t)) }
	F. <<- function(t) { FofY( Y.(t), param) }
	G. <<- function(t) { matrix(0, 2, 2) }
	suppressWarnings(
		return( -coalescent.log.likelihood(bdt, integrationMethod = 'adams', finiteSizeCorrections=FALSE) )
	)
}


#~ now fit the model
#~ NOTE well: this will take about 30 minutes
fit <- mle(integrate.model.calculate.minusLogLikelihood, 
	   start = list( log_b_in=log(.75), log_b_cross=log(.75),  logY0_0 = log(1)), # note uninformative starting conditions
	   method='Nelder-Mead',
	   control=list(maxit=1000 ) )

# now inspect the output
summary(fit)
unname( exp(coef(fit))  )
AIC(fit)
#~ bias
unname( c(b00,b01,1) - exp(coef(fit)) ) #bias of the initial conditions parameter is inconsequential


#~ approximate 95pc confidence intervals using the mle object
#~ NOTE : more accurate confidence intervals could be found using the profile(fit) function. I recommend using the more robust version of profile in the bbmle package
cis <- unname( rbind( exp( coef(fit) - diag( sqrt( vcov(fit) )) * 1.96 ), 
 exp( coef(fit) + diag( sqrt( vcov(fit) )) * 1.96 ) ) )
 colnames(cis) <- c('bin', 'bcross', 'Y0_0')
cis


#~ plot and fitted trajectories to actual trajectories
with(bdSimulationData,  {
plot(t, Y0+.01, 'l', ylim=c(0.01, max(c(Y0,Y1))), col='blue', log='y' )
lines(t, Y1, col='red')
})

theta <- as.list( coef(fit)  )
with(theta, {
param <- list(b00 = unname(exp(log_b_in)), b01 = unname(exp(log_b_cross)), b10= unname(exp((log_b_cross))), b11 = unname(exp(log_b_in)) ) 
X0 <-c( Y0=exp(logY0_0), Y1=0)
times <- seq(0, simulationTime, length.out = 100)
o <- ode(X0, times, dX, param)
lines(o[,1], o[,2], col='blue')
lines(o[,1], o[,3], col='red')
})


#~ OUTPUT phi = .25
#~ Coefficients:
#~                Estimate Std. Error
#~ log_b_in    -0.01002211 0.08536522
#~ log_b_cross -0.84066718 0.18859722
#~ logY0_0      0.69587134 0.20992137
#~ -2 log L: 1895.335 
#~ > unname( exp(coef(fit))  )
#~ [1] 0.9900279 0.4314226 2.0054557
#~ > unname( c(b00,b01,1) - exp(coef(fit)) )
#~ [1]  0.009972055  0.068577408 -1.005455745
#~ > cis
#~            bin    bcross     Y0_0
#~ [1,] 0.8374967 0.2981025 1.328998
#~ [2,] 1.1703393 0.6243672 3.026229
